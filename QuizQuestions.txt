Q1) Which are legal?
A) var x;
B) var x = 99;
C) private var x = "Hello";
D) var x;
   x = 100;
E) var [] x = {1, 3, 5};

Q2) Given:
public void doStuff(int [] ia) { /* ... */ }

which are legal invocations?

A) int [] ia = null;
   doStuff(ia);
B) doStuff({1, 2, 3})
C) doStuff(int[]{1, 2, 3});
D) doStuff(new int[]{1, 2, 3});

Q) Which print true?
A) var x = "Hello";
   var y = "Hello";
   sout(x == y);

B) var x = "Hello";
   var y = "Hello";
   sout(x.equals(y));

C) var x = new StringBuilder("Hello");
   var y = "Hello";
   sout(x.equals(y));

D) var x = new StringBuilder("Hello");
   var y = new StringBuilder("Hello");
   sout(x.equals(y));

Q) Which compile?
A) int x = 0;
   if (x) { sout("true"); }

B) boolean x = false;
   if (x) { sout("true"); }

C) Boolean x = false;
   if (x) { sout("true"); }

D) if (Math.random() > 5) {
     sout("Big!");
   } elif (Math.random() > 2) {
     sout("not so big");
   } else sout("dunno");

Q) Which compile?

A) int x = 99;
   switch(x) {
   case 99: sout("99");
   default: sout("something else");
   }

B) long x = 99;
   switch(x) {
   case 99: sout("99");
   }

C) String x = "99";
   switch(x) {
   case "99": sout("99");
   default: sout("something else");
   }

D) StringBuilder x = new StringBuilder("99");
   switch(x) {
   case 99: sout("99");
   default: sout("something else");
   }

Q) Given:
    class X {
        static int MAX_VAL = 100;
        int value = 99;
        public void setVal(int x) {
            if (x <= MAX_VAL) value = x;
        }
    }
and:
        X a = new X();
        X b = new X();
        a.setVal(120);
        System.out.print(a.value + ", ");
        b.MAX_VAL = 150;
        a.setVal(140);
        System.out.println(a.value);

What is the result?
    A) 99, 99
    B) 120, 140
    C) 99, 140
    D) Compilation failure
    E) Exception at runtime

Q) Given:
    class Base {
        void doBaseStuff() {
            System.out.println("doBaseStuff");
        }
    }
    class Sub extends Base {
        void doBaseStuff() {
            System.out.println("doSubStuff");
        }
        void doOtherStuff() {
            System.out.println("doOtherStuff");
        }
    }



In the Base and Sub classes, which are true in isolation?
    A) doBaseStuff in Base can be marked public without causing errors
    B) doBaseStuff in Base can be marked private without causing errors
    C) doBaseStuff in Sub can be marked public without causing errors
    D) doBaseStuff in Sub can be marked protected without causing errors
    E) doBaseStuff in Sub can be marked private without causing errors

Q) In the Base and Sub classes, which are true in isolation?
    A) doBaseStuff in Base can be marked throws Exception without causing errors
    B) doBaseStuff in Base can be marked throws RuntimeException without causing errors
    C) doBaseStuff in Sub can be marked throws Exception without causing errors
    D) doBaseStuff in Sub can be marked throws RuntimeException without causing errors
    E) if doBaseStuff in Base were marked throws Exception,
       then doBaseStuff in Sub can be marked throws IOException without causing errors

Q) Given
    class Q23Base {
        public Q23Base get() {
            return null;
        }
    }


    class Q23Sub extends Q23Base { ...
Which methods may individually be added to this class?
   A) public Q23Base get() { return null; }
   B) public Q23Sub get() { return null; }
   C) public Runnable get() { return null; }

// "Covariant" return yes, but ONLY for Object types, NOT primitives 

Q) Q9)
Which are legal (individually):
A) Criterion<Student> sc = Student s -> { return s.getGpa() > 3;};
B) Criterion<Student> sc = s -> { s.getGpa() > 3 };
C) Object sc = s -> {return s.getGpa() > 3;};
D) Criterion<Student> sc = (s) -> s.getGpa() > 3;
E) Criterion<Student> sc = s -> s.getCourses().size();















